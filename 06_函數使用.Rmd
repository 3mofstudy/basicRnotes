# 函數介紹

## R 語言常用內建函數分類

R 語言的核心系統 (Base R) 提供了豐富的內建函數（Built-in Functions），這些函數是處理資料、執行運算和進行統計分析的基礎工具。它們可以被大致分為以下幾類：

| 函數種類 | 主要功能 | 常用內建函數 (範例) |
|:---|:---|:---|
| **數學運算 (Mathematical)** | 執行數值計算和數學轉換 | `abs()` (絕對值)、`sqrt()` (平方根)、`log()` (對數)、`exp()` (指數)、`round()` (四捨五入)、`ceiling()` (無條件進位)、`floor()` (無條件捨去)、`sin()`、`cos()` (三角函數) |
| **敘述統計 (Descriptive Statistics)** | 快速計算數據集的摘要統計量 | `sum()` (總和)、`mean()` (平均值)、`median()` (中位數)、`sd()` (標準差)、`var()` (變異數)、`min()` (最小值)、`max()` (最大值)、`range()` (範圍)、`quantile()` (分位數) |
| **資料結構/管理 (Data Management)** | 建立、操作或檢查 R 的資料物件 | `c()` (連接向量或列表)、`length()` (求長度)、`seq()` (建立等差序列)、`rep()` (重複)、`sort()` (排序)、`class()` (檢查物件類型)、`subset()` (求子集)、`unique()` (去重) |
| **字串處理 (String Manipulation)** | 處理和轉換文字/字元向量 | `paste()` / `paste0()` (連接字串)、`nchar()` (計算字元數)、`substr()` (取出子字串)、`toupper()` (轉大寫)、`tolower()` (轉小寫)、`strsplit()` (拆分字串) |
| **陣列/矩陣操作 (Matrix/Array)** | 處理多維資料結構 | `t()` (矩陣轉置)、`cbind()` (按列合併)、`rbind()` (按行合併)、`dim()` (取得維度)、`%*%` (矩陣乘法)、`apply()` (對陣列應用函數) |
| **機率與分配 (Probability/Distribution)** | 處理統計機率分配 | `rnorm()` (常態分布亂數)、`dnorm()` (常態機率密度)、`pnorm()` (常態累積機率)、`dbinom()` (二項式機率密度)、`sample()` (隨機抽樣) |
| **輸入/輸出 (I/O)** | 讀取或寫入檔案資料 | `read.csv()` (讀取 CSV)、`write.csv()` (寫入 CSV)、`read.table()` (讀取表格)、`saveRDS()` (儲存 R 物件) |

在 R 語言中，每個函數的使用方式都是 `函數名稱(參數1, 參數2, ...)` 的形式。其中，括號內的**參數 (argument)** 用來控制函數執行的方式或指定輸入的資料。

例如，處理有缺失值 (NA) 的資料時，可以使用 `mean()` 函數的 `na.rm = TRUE` 參數來忽略這些缺失值：

```{r eval=FALSE}
scores <- c(85, 92, 78, 90, NA) # 包含一個缺失值 NA

# 1. 直接計算：會回傳 NA
mean(scores)

# 2. 使用參數調整：移除缺失值後計算平均
mean(scores, na.rm = TRUE)

```

## 實用套件之函數

R 生態系提供大量功能強大的套件，能大幅提升資料處理、資料視覺化、 文字處理、日期處理、統計模型與機器學習等分析效率。 下表整理 11 個最常用、最知名的 R 套件

| 套件名稱 | 主要用途分類 | 簡短介紹 |
|----|----|----|
| **tidyverse** | 資料處理 / 視覺化 / 整潔資料 | 包含 dplyr、tidyr、ggplot2 等，是 R 的核心分析工具。 |
| **dplyr** | 資料處理（filter / select / mutate） | 快速且直覺的資料操作語法。 |
| **ggplot2** | 資料視覺化 | 高彈性統計繪圖，建立高品質圖表。 |
| **tidyr** | 資料整形（Wide ↔ Long） | 處理資料格式整理，如 pivot_longer() / pivot_wider()。 |
| **forcats** | 類別資料處理（factor） | 最好用的 factor 操作工具，如排序、重新編碼。 |
| **data.table** | 高速資料處理 | 超大資料量下的高效運算利器。 |
| **lubridate** | 日期與時間處理 | 提供簡單直覺的日期運算工具。 |
| **stringr** | 字串處理 | 統一介面的字串操作。 |
| **shiny** | 互動式儀表板 | 用 R 建立網頁應用程式。 |
| **caret** | 機器學習 | 整合多種 ML 模型的統一介面。 |
| **reticulate** | 與 Python 互動 | 可呼叫 Python、匯入 Python 模組、執行 Python 物件。 |

## 自訂函數

在 R 語言中，自定義函數（Custom Functions） 是用戶可以根據自己的需求編寫並使用的函數。這些函數可以執行任何你想要的任務，從簡單的計算到複雜的數據處理。以下是一個簡單的例子，說明如何創建和使用自定義函數。 自定義函數的基本結構 自定義函數的一般形式如下：

```{r}
function_name <- function(arguments) {
  # 函數主體
  # 這裡是函數要執行的代碼
  return(value)
}
```

範例1: 簡單加法函數

```{r}
add_numbers <- function(a, b) {
  sum <- a + b
  return(sum)
}
#使用這個函數
result <- add_numbers(3, 5)
print(result)  # 輸出：8

```

範例2: 計算圓的面積

```{r}
calculate_area <- function(radius) {
  area <- pi * radius^2
  return(area)
}
#使用這個函數
circle_area <- calculate_area(4)
print(circle_area)  # 輸出：50.26548

```

範例3: 處理數據框的函數

```{r}
column_means <- function(dataframe) {
  means <- sapply(dataframe, mean, na.rm = TRUE)
  return(means)
}

# 創建示例數據框
data <- data.frame(
  x = c(1, 2, 3, 4, 5),
  y = c(6, 7, 8, 9, 10),
  z = c(11, 12, 13, 14, 15)
)

# 計算每列的平均值
means <- column_means(data)
print(means)  # 輸出： x y z 
              #        3 8 13

```

## do.call 及call

### 1. do.call 基本用途

簡單的講，do.call 的功能就是執行一個函數，而這個函數的參數呢，放在一個list裡面, 是list的每個子元素，見下列範例: do.call的第一個參數(what)預備執行的函數名稱,第二個參數(args)放list格式包起來的資料及相關函數設定，如下列範例:

```{r}
vec1 <- c(4,9,NA,8,12,74,36,NA,55)

do.call(mean, list(vec1)) ##輸出NA，因為無設定第二個參數值

do.call(mean, list(vec1,na.rm = TRUE)) ##排除遺失值後，計算平均值
```

### 2. do.call 常運用於data.frame的子元素

```{r}
dt <- data.frame('letter' = letters[1:10], 'number' = 1:10, 'value' = c('+','-'))
dt[[1]]
dt[[2]]
dt[[3]]
do.call(paste0,dt)
```

### 3. do.call 亦可運用於list 資料格式

```{r}
一心營業額 = list("北區"=data.frame("月份"= c(7,8,9,10) ,"銷售額"=c(10000,27000,68500,34000)),
                  "中區"=data.frame("月份"= c(7,8,9,10) ,"銷售額"=c(9000,10400,59400,48000)),
                  "南區"=data.frame("月份"= c(7,8,9,10) ,"銷售額"=c(8000,96000,70400,63500)))
do.call(rbind,一心營業額)
```

### call 與 do.call的差異

call 和 do.call很像，兩者主要差異:

1.  do.call() 執行某個已知現存的函數，例如內建函數`sum()`、`mean()`等，需將參數以**列表的形式**傳遞給函數後，才能正常運作。

```{r}
#自創一個能計算BMI的函數
BMI <- function(ht, wt) {
x <- wt / (ht / 100)^2
return(x)
}
# 建立一個有身高及體重資料集
DT <- data.frame("ht" = c(155, 168, 159), "wt" = c(80, 60, 48))
# 使用 do.call 將列表作為參數傳遞給 BMI 函數
result <- do.call(BMI, list(ht = DT$ht, wt = DT$wt))
# 印出結果
print(result)
```

2.  call() 以動態的方式生成函數呼叫，再用**`eval`**函數執行呼叫

```{r}
#自創一個能計算BMI的函數
BMI <- function(ht, wt) {
x <- wt / (ht / 100)^2
return(x)
}
# 建立一個有身高及體重資料集
DT <- data.frame("ht" = c(155, 168, 159), "wt" = c(80, 60, 48))
# 使用call函數動態生成函數呼叫
my_call <- call("BMI", ht = DT$ht, wt = DT$wt)
# 以eval函數執行生成的函數呼叫
result <- eval(my_call)
# 印出結果
print(result)
```

由上面兩段程式碼可以看出來，`call`函數還需要搭配`eval`函數執行後續的呼叫，所以實務上，**`do.call`**往往更常被使用，而另一個快速調用函數的方法則是**`apply`**家族

### 1.線上資源

-   [R do.call & call 函数教程](https://blog.csdn.net/neweastsun/article/details/122397987)
-   [R語言中eval和do.call的用法](https://www.twblogs.net/a/5d42ed0ebd9eee5327fb25a7)
-   [R語言do.call 函數用法詳解](https://www.cnblogs.com/Demo1589/p/6984537.html)
